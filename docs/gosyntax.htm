<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 
<head>
  <meta http-equiv="content-type"  content="text/html; charset=ISO-8859-1">
   <meta name=viewport content='width=device-width, initial-scale=1'>
  <link rel="stylesheet" href="style.css" type="text/css">
  <title></title>
</head>
<body>
<h1>Syntax of
GoFBP (Go Implementation of FBP)<br>
and Component API</h1>
<div class="content wrap">
			<section class="posts">
				<article class="post text">
				

<br>
<h3>Contents</h3>
<ul>
  <li><a href="#gen">General</a></li>
  <li><a href="#netdef">Network Definitions</a></li>
  <ul>
    <li><a href="#sampnet">Sample Network</a></li>
    <li><a href="#subnet">Simple Subnet</a></li> <br/>  
  </ul>
  <li><a href="#compcode">Component Coding</a> </li>
  <ul>
    <li><a href="#samplecomp">Sample Component</a></li>
    <li><a href="#metadata">Component Metadata</a></li>
    <!-- <li><a href="#actors">"Actors" (deprecated)</a></li> -->
    <li><a href="#compapi">Component API</a><br/>
    </li>
  </ul>
</ul>
<h3><a name="gen"></a>General </h3>
<p>In my book, "Flow-Based Programming", I describe the syntax of
the network specifications of various FBP dialects that were in
existence when the book was written. GoFBP, the Go implementation
of the FBP concepts, did not exist at that time, so this web page has
been added describing the syntax of GoFBP network definitions.
</p>
<p>As described in my book, many non-trivial applications can be built
using only the network definition language, so this web page starts
with a description of the network definition language.&nbsp; A running
program can be built up in layers, using GoFBP's <a href="#subnet">subnet</a>
notation(<i>not yet implemented</i>).&nbsp; There is also a diagramming tool (<a
 href="http://www.jpaulmorrison.com/fbp/#DrawFBP">DrawFBP</a>), which
can be used to define the network graphically, and which can actually
generate the network definitions (<i>not yet implemented</i>).&nbsp; <br>
</p>
<p>If new components have to be coded, they will be coded in Go,
using the Go component API.&nbsp;
</p>
<p>The source code for the various constituents of GoFBP is now being held on a public <a href="https://github.com/jpaulm/gofbp">GitHub</a> project.  There is also a <a href="https://github.com/jpaulm/gofbp/blob/master/README.md">README</a> file on the GitHub web site.

</p>


<h3><a name="netdef"></a>Network Definitions<br>
</h3>
<p>Since the way the syntax relates to the underlying diagram may not
be all that clear, a brief description is in order. &nbsp;At the end of
this page, I have given an extremely
simple GoFBP component.<br>
<br>
Any GoFBP network definition starts as follows (preceded by any necessary imports, including <code>"testing"</code> and <code>"github.com/jpaulm/gofbp/core"</code>):<br>
<br>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre><br>func Testxxxxxx(t *testing.T) { <br>
	net := core.NewNetwork("xxxxxx")<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>
	where <code>xxxxxx</code> is the FBP network name. The file name should be terminated with <code>_test.go</code>.
<p>The network definition is terminated with: </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>}<br>	net.Run()<br>}<br>}<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>In between the beginning and the ending statements defining the
network, you specify a list of connections, using the following
methods, which I will refer to as "clauses": </p>
<ul>
  <li> <code>NewProc</code> - define an FBP
"process" <br>
  </li>
  <li><code>Connect</code> - define a connection </li>
  <li> <code>Initialize</code> - define a connection including an Initial
Information Packet (IIP) </li>
  </ul>
<p>Every process <span style="font-style: italic;">must
have a unique character string</span>
identifying it, which allows other processes or initial
information packets (IIPs) to be attached to it via a connection. </p>
<p>The following method call:&nbsp;</p>
<p> <code> NewProc</code></p>
<p> returns a reference to a process.  This clause also specifies the name of the process code <code>.go</code> program  to be
executed. Thus:</p>

<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>     <br> proc1 := net.NewProc("xxxxxx", &testrtn.yyyyyy{})</br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p> where <code>xxxxxx</code> is a process name, and <code>yyyyyy</code> is the name of the <code>.go</code> program - the former has to be unique, but the latter doesn't have to be.


<p>A <code>Connect</code> or <code>Initialize</code> clause will contain a reference to two or one process variables, as e.g. </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
	      <pre>
               net.Connect(proc1, "OUT", proc3, "IN", 6)  
and
	       net.Initialize("15", proc1, "COUNT")
	</pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
	<p>It should be pointed out that the "value" of an <code>Initialize</code> clause may be any type - examples usually show `string`s, for compatibility with common DrawFBP usage. <br>
</p>
	<p>The 5th parameter of <code>Connect</code> is the capacity of the connection.
</p>
	
<p>The network definition is completed with the following: </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>   net.Run()
}
	</pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>	
<!--	<p><i>Following not implemented yet! </i></p> 	
<p>If an asterisk (<code>*</code>) is specified for the
"from" port, this is called an "automatic output port", and indicates a
signal generated when the "from"
component instance terminates (actually the port is just closed, so no
packet has to be disposed of).&nbsp; <br>
</p>
<p>If an asterisk (<code>*</code>) is specified for the "to" port,
this is called an "automatic input port", and indicates a <i>delay</i>
- the "to" component instance does not
start until a signal or a close is received at this port.<br>
</p>
<p>
If <code>*SUBEND</code> is specified as a port name on a subnet, a packet
containing null is
emitted at this port every time the subnet deactivates, i.e. all the
contained components terminate.&nbsp; It doesn't have to be named in
the port
metadata.&nbsp; This null packet is emitted for all
activations, including the last one.
</p>
<p>An <code>initialize</code> clause contains: </p>
<ul>
  <li> a reference to <i>any</i> object </li>
  <li> a <code>component</code> clause </li>
  <li> a <code>port</code> clause </li>
</ul>
<p> as e.g.<br>
</p>
<p>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>     initialize(new FileReader(<br>              "c:\\com\\jpmorrsn\\eb2engine\\test\\data\\myXML3.txt"),<br>    &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; component("Read"),<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; port("SOURCE"));<br>  </pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>However, it has been recommended that IIPs should be strings, rather
than arbitrary objects, to facilitate future graphical management
of networks.</p>
-->
<p>One last point: any number of "from" ports can be connected to a
single "to" port; only one "to" port can ever be connected to a given
"from" port.</p>
	<!--
<p>A "named global" facility has been provided - <code>putGlobal(String,
Object)</code> - which can be used to make an object available to all
components, using the <code>getGlobal(String): Object</code> method. </p>
<p><code>putGlobal(String, Object)</code> adds an object to a global
HashMap using a String as identifier; <code>getGlobal(String): Object</code>
can be used by a component to retrieve said object using the same
String value. </p>
<p>CAUTION: this is extremely dangerous, as it runs counter to FBP
philosophy. It should be used very carefully!
</p> -->
<h3><a name="sampnet"></a>Sample Network</h3>
	<p> Here is a simple network (<code>main.go</code>) illustrating indexed ports: </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre> <br> 
package main

import (	
	
	"github.com/jpaulm/gofbp/components/testrtn"
	"github.com/jpaulm/gofbp/core"
	
)

func main() {

	net := core.NewNetwork("RRDist")

	proc1 := net.NewProc("Sender", &testrtn.Sender{})

	proc2 := net.NewProc("RoundRobinSender", &testrtn.RoundRobinSender{})

	proc3a := net.NewProc("WriteToConsole", &testrtn.WriteToConsole{})
	proc3b := net.NewProc("Receiver1", &testrtn.Receiver{})
	proc3c := net.NewProc("Receiver2", &testrtn.Receiver{})

	net.Initialize("15", proc1, "COUNT")
	net.Connect(proc1, "OUT", proc2, "IN", 6)
	net.Connect(proc2, "OUT[0]", proc3a, "IN", 6)
	net.Connect(proc2, "OUT[1]", proc3b, "IN", 6)
	net.Connect(proc2, "OUT[2]", proc3c, "IN", 6)

	net.Run()

}
<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
	
<h3><a name="subnet"></a>Sample Subnet</h3>
	<p> Here is a simple subnet (<code>subnets/subnet1.go</code>): </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre> <br> 
package subnets

import (
	"github.com/jpaulm/gofbp/components/testrtn"
	"github.com/jpaulm/gofbp/core"
)

type Subnet1 struct{}

func (subnet *Subnet1) Setup(p *core.Process) {}

func (subnet *Subnet1) Execute(p *core.Process) {
	net := core.NewSubnet("Subnet1", p)

	proc1 := net.NewProc("SubIn", &core.SubIn{})

	proc2 := net.NewProc("WriteToConsole1", &testrtn.WriteToConsole{})

	proc3 := net.NewProc("SubOut", &core.SubOut{})

	net.Initialize("IN", proc1, "NAME")
	net.Connect(proc1, "OUT", proc2, "IN", 6)
	net.Connect(proc2, "OUT", proc3, "IN", 6)
	net.Initialize("OUT", proc3, "NAME")

	net.Run()
}

<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>	
<!--
<p>Now these <code>component</code> clauses may either be made into
separate
statements or they can be imbedded into the <code>connect</code>
statements that
follow.&nbsp; Here are the connections in the diagram, <span
 style="font-style: italic;">without</span> imbedded component clauses:<br>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>  connect(component("Read Masters"),port("OUT"),component("Collate"),<br>     port("IN",0));&nbsp; &nbsp;                   // array port  <br>  connect(component("Read Details"),port("OUT"),component("Collate"),<br>     port("IN",1));&nbsp; &nbsp; &nbsp;                 // array port  <br>  connect(component("Collate"),port("OUT"),<br>     component("Process Merged Stream"), port("IN"));  <br>  connect(component("Process Merged Stream"),port("OUTM"),<br>     component("Write New Masters"),port("IN"));  <br>  connect(component("Process Merged Stream"),port("OUTSE"),<br>     component("Summary &amp; Errors"),port("IN"));<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>So you can either separate your <code>component</code> and <code>connect
</code>statements, or add the
class designation to the first <code>component</code> clause referencing a
particular component occurrence, giving the following: </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre> &nbsp;<br>  connect(component("Read Masters",Read.class),port("OUT"),<br>&nbsp; &nbsp;  component("Collate",Collate.class), port("IN",0));   // array port  <br>&nbsp; connect(component("Read Details",Read.class),port("OUT"),<br>&nbsp;&nbsp; &nbsp; component("Collate"),port("IN",1));                  // array port  <br>&nbsp; connect(component("Collate"),port("OUT"),<br>     component("Process Merged Stream",Proc.class),port("IN"));  <br>  connect(component("Process Merged Stream"),port("OUTM"),<br>     component("Write New Masters",Write.class),port("IN"));  <br>  connect(component("Process Merged Stream"),port("OUTSE"),<br>     component("Summary &amp; Errors",Report.class),port("IN"));      </pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>Now "Read Masters" and "Read Details" use the same Go class, so we
need some way to indicate the name of the file that each is going to
read. This is done using Initial Information Packets (IIPs). In this
case they might usefully specify FileReader objects, so we need to add
two <code>initialize</code> clauses, as follows: </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>  <br>  initialize(new FileReader("c:\\mastfile"),<br>			component("Read Masters"),<br>			port("SOURCE"));<br>  initialize(new FileReader("c:\\detlfile"),<br>			component("Read Details"),<br>			port("SOURCE"));<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that, since both "Read" component occurrences use the same
class code,
they naturally have the same port names - of course, the ports are
attached
to different IIPs. </p>
<p>Remember that back-slashes have to be doubled in Go character
strings! Process names can contain any character - but double quotes in the name must be "escaped" using a back-slash.</p>
<p>"Write New Masters" will have to have an IIP to specify the output
destination - perhaps: </p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>  <br>  initialize(new FileWriter("c:\\newmast"),<br>			component("Write New Masters"),<br>			port("DESTINATION"));<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>Note also that this IIP is not a <i>destination</i> for the Writer
- it is an object <i>used</i> by this component occurrence so that the
latter can figure out where to send data to. </p>
<p>Add the beginning and ending statements, and you're done! &nbsp; The
actual sequence of <code>connect</code> and <code>initialize</code>
statements is irrelevant.</p>
<p>Here is the final result:<br>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>  <br>public class xxxxxx extends Network {<br><br>  protected void define() {<br>    connect(component("Read Masters",Read.class),port("OUT"),<br>      component("Collate",Collate.class),port("IN",0)); // array port  <br>    connect(component("Read Details",Read.class),port("OUT"),<br>      component("Collate"),port("IN",1));// array port  <br>    connect(component("Collate"),port("OUT"),<br>      component("Process Merged Stream",Proc.class),port("IN"));  <br>    connect(component("Process Merged Stream"),port("OUTM"),<br>      component("Write New Masters",Write.class),port("IN"));  <br>    connect(component("Process Merged Stream"),port("OUTSE"),<br>      component("Summary &amp; Errors",Report.class),port("IN"));<br>    initialize(new FileReader("c:\\mastfile"),<br>      component("Read Masters"),<br>      port("SOURCE"));<br>    initialize(new FileReader("c:\\detlfile"),<br>      component("Read Details"),<br>      port("SOURCE"));<br>    initialize(new FileWriter("c:\\newmast"),<br>      component("Write New Masters"),<br>      port("DESTINATION"));<br><br>    }<br><br>  public static void main(String[] argv) throws Exception{   <br>            <br>     new xxxxxx().go();<br>  }<br>}<br><br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<h3><a name="simpnot"></a>Simplified Notation (GoFBP-2.0+)<br>
</h3>
<p>
In the latest release of GoFBP, we have introduced a new, simplified
notation, in
addition to that shown above.&nbsp; In this notation <code>connect</code>
specifies
two character strings, and <code>initialize</code> specifies an object and
a character string.&nbsp;&nbsp; In both cases, the second character
string specifies a combination of component and port, with the two
parts separated by a period. Array port indices, if required, are
specified using square brackets,
e.g.
<p><code>"component.port[3]" </code> </p>
<p>The old port notation will still be supported, but is only really
needed
when the port index is a variable.&nbsp; When debugging, it will be
noted that the square bracket notation is used in trace lines, even
when it was not used in the network definition.<br>
</p>
<p>Component names must of course not include periods or most special
characters, but they may include blanks, numerals, hyphens and
underscores, and they must be associated with their implementing class
using a (preceding) <code>component</code> statement.<br>
</p>
<p>Here is the above network using the new notation:</p>
<p>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre> <br>public class xxxxxx extends Network {<br><br> protected void define() {<br>   component("Read Masters",Read.class); <br>   component("Read Details",Read.class);<br>   component("Collate",Collate.class);<br>   component("Process Merged Stream",Proc.class); <br>   component("Write New Masters",Write.class);<br>   component("Summary &amp; Errors",Report.class);<br>   connect("Read Masters.OUT", "Collate.IN[0]");<br>   connect("Read Details.OUT", "Collate.IN[1]");  <br>   connect("Collate.OUT"), "Process Merged Stream.IN"); <br>   connect("Process Merged Stream.OUTM", "Write New Masters.IN"); <br>   connect("Process Merged Stream.OUTSE", "Summary &amp; Errors.IN");<br>   initialize(new FileReader("c:\\mastfile"), "Read Masters.SOURCE");<br>   initialize(new FileReader("c:\\detlfile"), "Read Details.SOURCE");<br>   initialize(new FileWriter("c:\\newmast"), <br>              "Write New Masters.DESTINATION");<br>   }<br><br>  <br>public static void main(String[] argv) throws Exception {<br>                &nbsp;<br>        new xxxxxx().go();<br>   }<br>  }<br><br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>
Here is a network example showing how variable port numbers can be used
with the LoadBalance function to define an (admittedly fairly trivial)
self-balancing network.&nbsp; <br>
</p>
<p>This also shows a slightly different way
of specifying the <code>define</code> function, which avoids having to
remember to change the network name in the<small><span
 style="font-family: Courier New,Courier,monospace;"> main()</span></small>
method, when you do cut and paste.&nbsp; Its disadvantage is that trace
output will show a "generated" network name, rather than the actual one.<br>
<br>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre><br>public class TestLoadBalancer {<br><br>  public static void main(final String[] args) {<br>    try {<br>      new Network() {<br>        @Override<br>        protected void define() {<br>          int multiplex_factor = 10;<br>          component("generate", Generate.class);<br>          component("display", WriteToConsole.class);<br>          component("lbal", LoadBalance.class);<br>          connect("generate.OUT", "lbal.IN");<br>          initialize("100 ", component("generate"), port("COUNT"));<br>          for (int i = 0; i &lt; multiplex_factor; i++) {<br>            connect(component("lbal"), port("OUT", i), <br>                component("passthru" + i, Passthru.class), port("IN"));<br>            connect(component("passthru" + i), port("OUT"), "display.IN");<br>          }<br>        }<br>      }.go();<br>    } catch (Exception e) {<br>      System.err.println("Error:");<br>      e.printStackTrace();<br>    }<br>  }<br>}<br><br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
-->
	<h3>Indexing Port Names</h3>
	<p>FBP supports array-type input and output ports - these are indicated in the <code>Connect</code> statements using square brackets.</p>
<h3><a name="subnet"></a>Simple Subnet</h3>
<p>
As described in the book, networks can be built up level by level,
using what we call "subnets" - they may be thought of as networks with
"sticky" connections.&nbsp; Here is a very simple subnet.<br>
<p>
	<!--
Note the metadata - a subnet can act as a component, so metadata is
required.<br>
<br>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre><br>@OutPort("OUT")<br>@InPort("IN")<br>public class SubnetX extends SubNet {<br>@Override<br>  protected void define() {<br>    component("SUBIN", SubInSS.class); // substream-sensitive<br>    component("SUBOUT", SubOutSS.class); // do.<br>    component("Pass", Passthru.class);<br>    initialize("IN", component("SUBIN"), port("NAME"));<br>    connect(component("SUBIN"), port("OUT"), component("Pass"), port("IN"));<br>    connect(component("Pass"), port("OUT"), component("SUBOUT"), port("IN"));<br>    initialize("OUT", component("SUBOUT"), port("NAME"));<br>  }<br>}<br><br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
-->
<!--<h3><a name="actors"></a>Network using ActorDriver Component<br>
</h3>
This network executes the "string of pearls" pattern of 100 actors
described in the soon-to-be published 2nd Edition of the book on
Flow-Based Programming.&nbsp; All the occurrences of Act1 and Act2 run
under the same process (ActorDriver).<br>
<br>
<table style="width: 734px; height: 1063px;" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre><br><br><br>import com.jpmorrsn.fbp.components.Discard;<br>import com.jpmorrsn.fbp.components.Generate;<br>import com.jpmorrsn.fbp.components.OutActor;<br>import com.jpmorrsn.fbp.engine.ActorDriver;<br>import com.jpmorrsn.fbp.engine.Network;<br>import com.jpmorrsn.fbp.test.components.Act1;<br>import com.jpmorrsn.fbp.test.components.Act2;<br><br><br>/** This network is intended for testing ActorDriver */<br><br>public class TestActorDriver extends Network {<br><br>  static final String copyright = "Copyright 2007, 2008, 2010, " +<br>  		"J. Paul Morrison.  At your option, you may copy, "<br>      + "distribute, or make derivative works under the terms of the " +<br>      		"Clarified Artistic License, "<br>      + "based on the Everything Development Company's Artistic " +<br>      		"License.  A document describing "<br>      + "this License may be found at " +<br>      		"http://www.jpaulmorrison.com/fbp/artistic2.htm. "<br>      + "THERE IS NO WARRANTY; USE THIS PRODUCT AT YOUR OWN RISK.";<br><br>  @Override<br>  protected void define() {<br><br>    connect(component("Generate", Generate.class), port("OUT"), <br>        component("ActorDriver", ActorDriver.class), port("IN"));<br>    connect(component("ActorDriver"), port("OUT[0]"), <br>        component("Discard", Discard.class), port("IN"));<br>    initialize("100000", component("Generate"), port("COUNT"));<br>    Object[] classes = {<br>        "Act2",<br>        Act2.class,<br>        "Act1",<br>        Act1.class,<br>        "OutActor",<br>        OutActor.class,<br>        "Act1 -&gt; Act2.a -&gt; Act2.b -&gt;Act2.c -&gt;Act2.d -&gt;Act2.e -&gt;" + <br>        "Act2.f-&gt;Act2.g-&gt;Act2.h -&gt;"<br>            + "Act2.i -&gt;Act2.j-&gt;Act2.k-&gt;Act2.l-&gt;Act2.m-&gt;Act2.n -&gt;" + <br>            "Act2.o -&gt;Act2.p -&gt;Act2.q -&gt;Act2.r -&gt;"<br>            + "Act2.i2 -&gt;Act2.j2-&gt;Act2.k2-&gt;Act2.l2-&gt;Act2.m2-&gt;" + <br>            "Act2.n2 -&gt;Act2.o2 -&gt;Act2.p2 -&gt;Act2.q2 -&gt;Act2.r2 -&gt;"<br>            + "Act2.i3 -&gt;Act2.j3-&gt;Act2.k3-&gt;Act2.l3-&gt;Act2.m3-&gt;Act2.n3 -&gt;" + <br>            "Act2.o3 -&gt; Act2.p3 -&gt;Act2.q3 -&gt;Act2.r3 -&gt;"<br>            + "Act2.i4 -&gt;Act2.j4-&gt;Act2.k4-&gt;Act2.l4-&gt;Act2.m4-&gt;" + <br>            "Act2.n4 -&gt;Act2.o4 -&gt;Act2.p4 -&gt;Act2.q4 -&gt;Act2.r4 -&gt;"<br>            + "Act2.i5-&gt;Act2.j5-&gt;Act2.k5-&gt;Act2.l5-&gt;Act2.m5-&gt;Act2.n5 -&gt;" + <br>            "Act2.o5 -&gt;Act2.p5 -&gt;Act2.q5 -&gt;Act2.r5 -&gt;"<br>            + "Act2.i6 -&gt;Act2.j6-&gt;Act2.k6-&gt;Act2.l6-&gt;Act2.m6-&gt;" + <br>            "Act2.n6 -&gt;Act2.o6 -&gt;Act2.p6 -&gt;Act2.q6 -&gt;Act2.r6 -&gt;"<br>            + "Act2.i7 -&gt;Act2.j7-&gt;Act2.k7-&gt;Act2.l7-&gt;Act2.m7-&gt;" + <br>            "Act2.n7 -&gt;Act2.o7 -&gt;Act2.p7 -&gt;Act2.q7 -&gt;Act2.r7 -&gt;"<br>            + "Act2.i7 -&gt;Act2.j8-&gt;Act2.k8-&gt;Act2.l8-&gt;Act2.m8-&gt;" + <br>            "Act2.n8 -&gt;Act2.o8 -&gt;Act2.p8 -&gt;Act2.q8 -&gt;Act2.r8 -&gt;"<br>            + "Act2.i9 -&gt;Act2.j9-&gt;Act2.k9-&gt;OutActor (0)" };<br>    initialize(classes, component("ActorDriver"), port("ACTS"));<br><br>  }<br><br>  public static void main(final String[] argv) throws Exception {<br>    new TestActorDriver().go();<br>  }<br>}<br><br><br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<br>
Parameter, if any, follows qualifier, if any.&nbsp; In the case of
"fan-out" actors, the output port element number follows qualifier and
parameter.<br>
<br>
Either qualifier or parameter can be used to make an occurrence of an
actor name unique.<br> -->
	
	<!--
	
<h3><a name="compcode"></a>Component Coding</h3>

<p>Components are basically simple Go classes, which extend <code>Component</code>.  The class <code>Component</code> really describes a GoFBP "process", (or instance of a component), but has been retained for historical reasons. 
<h3><a name="samplecomp"></a>Sample Component</h3>
<p>This component generates a stream of 'n' IPs, where 'n' is specified
in an InitializationConnection (specified by an <code>initialize</code>
clause in the foregoing). Each IP just contains an arbitrary string of
characters, in
order to illustrate the concept.&nbsp; Of course any copyright
information included is up to the developer.<br>
</p>
<p>The statements starting with <small><span
 style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>
are called the component metadata, and are described below in the
section called <a href="#metadata">"Component Metadata"</a>.<br>
</p>
<p>A GoFBP component basically consists of 5 sections:<br>
</p>
<ul>
<li>package</li>
  <li>import statements</li>
  <li>metadata</li>
  <li>declares for ports<br>
  </li>
  <li><code>openPorts()</code> 
method</li>
  <li><code>execute()</code> 
method<br>
  </li>
</ul>
<p>Here is a sample component:<br>
</p>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>package com.jpmorrsn.fbp.components;<br><br><br>import com.jpmorrsn.fbp.engine.*;<br><br><br><br>/** Component to generate a stream of 'n' packets, where 'n' is<br>* specified in an InitializationConnection.<br>*/<br><br><br>@OutPort(value = "OUT", description = "Generated stream", <br>       type = String.class)<br>@ComponentDescription(<br>       "Generates stream of packets under control of a counter")<br>@InPort(value = "COUNT", <br>       description = "Count of packets to be generated", <br>       type = String.class)<br><br>public class Generate extends Component {<br><br>static final String copyright = "Copyright .....";<br><br><br><br>	OutputPort outport;<br><br>	InputPort count;<br><br>  <br>  @Override<br>  protected void openPorts() {<br>	outport = openOutput("OUT");<br>	count = openInput("COUNT");		<br>	}<br><br>  @Override<br>  protected void execute() {<br>    Packet ctp = count.receive();<br>    if (ctp == null) {<br>      return;<br>    }<br>    count.close();<br><br>    String cti = (String) ctp.getContent();<br>    cti = cti.trim();<br>    int ct = 0;<br>    try {<br>      ct = Integer.parseInt(cti);<br>    } catch (NumberFormatException e) {<br>      e.printStackTrace();<br>    }<br>    drop(ctp);<br><br>    for (int i = 0; i &lt; ct; i++) {<br>      int j = ct - i;<br>      Integer j2 = new Integer(j);<br>      String s = j2.toString();<br>      if (j &lt; 10) {<br>        s = "0" + s;<br>      }<br>      if (j &lt; 100) {<br>        s = "0" + s;<br>      }<br>      s = s + "abc";<br><br>      Packet p = create(s);<br>      outport.send(p);<br><br>    }<br><br>  }<br><br>}</pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<p>The scheduling rules for most FBP implementations are described in
the chapter of my book called <a href="schedrls.htm">Scheduling Rules</a>.
</p>
<p>In earlier GoFBP versions, the scheduler&nbsp;<span
 style="color: rgb(0, 0, 153);"></span>presented an IIP
to a component <span style="font-style: italic;">once per invocation</span>.
This
has
been
changed
as
of <span style="color: rgb(0, 0, 153);">GoFBP-2.6</span>
to <span style="font-style: italic;">once per
activation</span>.&nbsp; In practice this will only affect
"non-loopers" (components that
get reactivated multiple times).&nbsp;&nbsp; <br>
</p>
<p>There are a few other minor changes to component code as of <span
 style="color: rgb(0, 0, 153);">GoFBP-2.0:</span>
</p>
<ul>
  <li>As good programming practice, we now feel that IIP ports should
be closed after a receive has been executed, in case it is attached to
an upstream component (rather than an IIP), and that component
mistakenly sends more than one IP - this statement has accordingly been
added to the above example.</li>
  <li> The <code>drop</code> statement now takes the packet as a parameter, rather
than
being a method of Packet. </li>
  <li>The send is now unconditional - it either works or crashes (it
can be made conditional by means of the <small><span
 style="font-family: Courier New,Courier,monospace;">isConnected() </span></small>method).</li>
  <li> We are adding a "long wait" state to components, specifying a
timeout value in seconds. This is coded as follows: </li>
  <p> </p>
 <pre>
        double _timeout = 2;   // 2 secs
  
            ....
            
        longWaitStart(_timeout);            
                                                  
  //   activity taking time goes here                                                       
                                                       
       longWaitEnd(); 
                                                             
</pre>
  <li> Typically, the timeout value is given a default value in the
code, or it can be overridden (if desired) by an IIP. </li>
  <li> While the component in question is executing the activity taking
time, its state will be set to "long wait". If one or more components
are in "long wait" state while all other components are suspended or
not started, this situation is not treated as a deadlock. However, if
one of the components exceeds its timeout value, an error will be
reported (<code>complain</code>). </li>

  <li>A major change - metadata, as shown in the
above component.&nbsp; </li>
<li>As of <span
 style="color: rgb(0, 0, 153);">GoFBP-2.8</span> we have added a new attribute of GoFBP connections: the <code>dropOldest</code> attribute.  This is specified by having <code>connect</code> return a <code>Connection</code> object, and then invoking <code>setDropOldest()</code> on it.  Here is an example:
<p> </p>
  <pre>
        Connection c = connect(component("Generate", GenerateTestData.class), 
                        port("OUT"),        
                        component("SlowPass", SlowPass.class), port("IN"));
        
        c.setDropOldest();
                                                             
</pre>

<p>A connection tagged with <code>dropOldest</code> will still activate an inactive downstream process, but, if the feeding process would normally suspend because there is no room for new data packets in the connection, the oldest IP will be dropped.  This attribute is useful when a measuring device is generating a stream of measurements, and it is not necessary to process every single one.  A similar case might be that of mouse movement events during a "drag" function.
</li>
<li>As of <span
 style="color: rgb(0, 0, 153);">GoFBP-3.0.2</span> <code>LoadBalance</code> has been modified so that all the IPs in a substream are routed to the same output port element.
 <p>There is also a corresponding component called <code>SubstreamSensitiveMerge</code>, but, if this is combined with <code>LoadBalance</code>, there is a 
 strong possibility of deadlocks - see <a href="https://github.com/jpaulm/javafbp/issues/8">GitHub/GoFBP Issue #8</a>.
	<p><code>SubstreamSensitiveMerge</code> uses a new API call, <code>Component.findInputPortElementWithData</code> - this function is not intended for general use, 
but may be useful in certain situations.
		
 
 </li>
</ul>


<h3><a name="metadata"></a>Component Metadata:</h3>
<ul>

  <li> Input and output port names will be coded on components using
Go
5.0 "attribute" notation. This metadata can be used to do
analysis of networks without having to actually execute the components
involved. Here is an example of the attributes for the "Collate"
component: </li>
  <p> </p>
  <pre>    @OutPort("OUT") <br>    @InPorts({<br>      @InPort("CTLFIELDS"), <br>      @InPort(value = "IN", arrayPort = true)<br>      })  <br><br>    public class Collate extends Component {<br></pre>
  <p> </p>
  <li> Note that, as Go metadata does not support
multiple entries with the same name, we have provided the additional
metadata terms <small><span
 style="font-family: Courier New,Courier,monospace;">@InPorts</span></small>
and <small><span style="font-family: Courier New,Courier,monospace;">@OutPorts</span></small>.
When
only
one
is
needed
(as
for





























    <small><span style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>
in this example) the "plural" term can be omitted. </li>
  <li> As shown above for<small><span
 style="font-family: Courier New,Courier,monospace;"> "CTLFIELDS"</span></small>,
when
no
attributes
are
needed
within
an






























    <small><span style="font-family: Courier New,Courier,monospace;">@InPort</span></small>
or <small><span style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>
statement, the short notation (no "value"
clause) can be used. </li>
  <li> Input ports do not necessarily have to be connected, even though
attributes are specified for them; output ports, however, must be
(unless <span style="font-family: monospace;">optional</span> is
specified on the <small><span
 style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>
term - see below). </li>
  <li> <span class="wikipagelink">MustRun</span> is also specified as
metadata, rather
than as an interface, as it was in version 1.5.3, i.e.
    <pre>    @MustRun</pre>
  </li>
  <li>There is a complete list of the metadata annotations in <a
 href="#metadata2">metadata</a> below. </li>
  <li>The following addition was made in version<span
 style="color: rgb(0, 0, 153);"> 2.2</span>:</li>
  <ul>
    <li><code>&lt;output port name&gt;.isConnected</code> returns <code>boolean</code>
    </li>
    <li> To support <code>isConnected</code>, a new metadata attribute
called <code>optional</code>
has been added to <small><span
 style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>,
e.g.






















    </li>
    <pre style="margin-left: 40px;">@OutPort(value = "OUT", optional = true)</pre>
    <br>
  </ul>
  <li>The following changes and additions have been made in version<span
 style="color: rgb(0, 0, 153);"> 2.5</span>:</li>
  <ul>
    <li>Network definitions are Go executable code, so port names can
be computed rather than explicitly spelled
out (as in the example above).&nbsp; However,&nbsp; <small><span
 style="font-family: Courier New,Courier,monospace;">@InPort</span></small>
and <small><span style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>
do not support this kind of symbol manipulation, so a<small><span
 style="font-family: Courier New,Courier,monospace;"></span></small>
parameter has been added to these classes called <small><span
 style="font-family: Courier New,Courier,monospace;">setDimension</span></small>,
which
allows
a
series
of
port
names
consisting
of
a
string
followed
by
numbers
from
0 on up to 'n-1' to be specified, where the <small><span
 style="font-family: Courier New,Courier,monospace;">setDimension</span></small>
argument
is
'n'.&nbsp;&nbsp;</li>
  </ul>
</ul>
<ul>
  <ul>
    <li>In this case, the value string must end with an
asterisk, and the asterisk will be replaced with the numbers 0, 1, 2,
... 9, 10, 11, etc.&nbsp; Thus, if the name
is
specified as <small><span
 style="font-family: Courier New,Courier,monospace;">"IN*"</span></small>,
and






















      <small><span style="font-family: Courier New,Courier,monospace;">setDimension(4</span></small>),
this
will
be
equivalent
to


















      <small><span style="font-family: Courier New,Courier,monospace;">"IN0",
"IN1",
"IN2",
"IN3"</span></small>.</li>
  </ul>
</ul>
<ul>
  <ul>
  </ul>
</ul>
<ul>
  <ul>
    <li>A new parameter, <small><span
 style="font-family: Courier New,Courier,monospace;">valueList()</span></small>,
has
been
added
to
the





















      <small><span style="font-family: Courier New,Courier,monospace;">@InPort</span></small>
and <small><span style="font-family: Courier New,Courier,monospace;">@OutPort</span></small>
annotations,
allowing a list of names of ports with the same attributes to be
specified.&nbsp; If <small><span
 style="font-family: Courier New,Courier,monospace;">valueList()</span></small>
is used in conjunction with <small><span
 style="font-family: Courier New,Courier,monospace;">setDimension()</span></small>,
at
least
one
list
element
must
end
with
an
asterisk.&nbsp;
List
elements
without
the
asterisk
will
just
ignore
the


      <small><span style="font-family: Courier New,Courier,monospace;">setDimension



      </span></small>parameter.<br>
    </li>
  </ul>
</ul>
<ul>
  <ul>
    <li>A new annotation, <small><span
 style="font-family: Courier New,Courier,monospace;">@SelfStarting</span></small>,
has
been
added,
indicating
that
the
process
starts
at
the
beginning
of
job
















      <span style="font-style: italic;">even if</span> it
has input ports.</li>
    <br>
    <li>A new Exception has been added as of GoFBP 2.5: <small><span
 style="font-family: Courier New,Courier,monospace;">ComponentException</span></small>.&nbsp;
This
can
be
used
to
terminate
a
component
occurrence
from

      <span style="font-style: italic;">inside</span> a
nested subroutine.&nbsp; It is thrown with an
integer argument, and will be caught by the nearest "catch" going up
the call stack.&nbsp; If there are no "catch"es lower down, the throw
will be caught by the scheduler, and the component occurrence will
deactivate.&nbsp; At this point, its behaviour, after deactivating,
will be as follows for various values of the integer argument:</li>
  </ul>
</ul>
<ul>
  <ul>
    <ul>
      <li>0:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
none</li>
      <li>1-999:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
generate
a
trace
line
if
tracing
enabled</li>
      <li>1000 or greater:&nbsp; bring down the network with a
"complain"
call. <br>
      </li>
    </ul>
  </ul>
</ul>
<ul>
  <ul>
    <li>A <small><span
 style="font-family: Courier New,Courier,monospace;">ComponentException</span></small>
can also be thrown with a string argument, in which case the integer
value is treated as zero.</li>
  </ul>
</ul>
<ul>
  <ul>
  </ul>
</ul>
<p>
Input ports and input array port elements are always treated as
optional.<br>
<br>
<h3><a name="metadata2"></a>Component Metadata</h3>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre><span style="text-decoration: underline;">Component Metadata:</span><br><br>Note: when "value" is the only parameter, the "short" form <br>   (see above) can be used<br><br>@ComponentDescription<br>  parameters:<br>    - value (String)<br><br>@InPort<br>  parameters:<br>    - value (String)<br>    - valueList({String, String, ... })<br>    - arrayPort (boolean)<br>    - description (String)<br>    - type (class)<br>    - setDimension (int)  --- requires * at end of value, or some entries in valueList
    - fixedSize (boolean) - only relevant if arrayPort
    <br>@OutPort<br>  parameters:<br>    - value (String)<br>    - valueList({String, String, ... })<br>    - arrayPort (boolean)<br>    - description (String)<br>    - type (class)<br>    - setDimension (int)  --- requires * at end of value, or some entries in valueList
    - optional (boolean)
    - fixedSize (boolean) - only relevant if arrayPort - cannot coexist with optional<br><br>@InPorts<br>  parameter: list of @InPort references, e.g. @InPorts( { @InPort("IN"), <br>     @InPort("TEST") })<br><br>@OutPorts<br>  parameter: list of @OutPort references, e.g. @OutPorts( { @OutPort("ACC"), <br>     @OutPort("REJ") })<br><br><br>@MustRun                 // Must run at least once<br><br>@SelfStarting            // Start process at beginning of run, even if it has input ports   <br><br>@Priority(Thread.MAX_PRIORITY)   // default is NORM_PRIORITY<br><br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>

<h3><a name="compapi"></a>Component API</h3>
<h4>Packet class</h4>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>/** <br>* A Packet may either contain an Object, when type is NORMAL,<br>* or a String, when type is not NORMAL.  The latter case<br>* is used for things like open and close brackets (where the <br>* String will be the name of a group. e.g. accounts) <br>**/<br><br>Object getAttribute(String key);  /* key accesses a specific attribute */<br>Object getContent();  /* returns null if type &lt;&gt; NORMAL */<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Component class</h4>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>/** <br>* All verbs must extend this class, defining its two abstract methods:<br>* openPorts, and execute. <br>**/<br><br><br>Packet p = create(Object o);<br><br><br>Packet p = create(Packet.type (int) t, String s);<br><br>drop(Packet p);   //  Note this change! <br><br>longWaitStart(double interval);   // in seconds<br>longWaitEnd();<br><br><br><br>/** 3 stack methods - as of GoFBP-2.3<br>**/<br><br>push (Packet p);<br><br>Packet p = pop();  // return null if empty<br><br>int stackSize();<br><br>int findInputPortElementWithData(InputPort[] inPortArray)  // as of v3.0.2<br> // inPortArray is created by the openInputArray function in openPorts()<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>InputPort interface</h4>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>Packet = receive();<br><br>void close();<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Connection class</h4>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>void setDropOldest();  // as of 2.8<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
<h4>OutputPort class</h4>
<table width="100%" border="2" cellpadding="2">
  <tbody>
    <tr>
      <td bgcolor="#ffffff">
      <pre>void send(Packet packet); <br><br>boolean isConnected();  // as of 2.2<br><br>void close();<br></pre>
      <p> </p>
      </td>
    </tr>
  </tbody>
</table>
-->
</article>
</section>
</div>
</body>
</html>
